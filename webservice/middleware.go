package webservice

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"time"

	"github.com/cryingmouse/data_management_engine/common"
	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
	"github.com/nicksnyder/go-i18n/v2/i18n"
	log "github.com/sirupsen/logrus"
)

// Middleware function to log request and response information
func LoggingMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Read the request body
		body, _ := io.ReadAll(c.Request.Body)

		// Restore the request body
		c.Request.Body = io.NopCloser(bytes.NewBuffer(body))

		// Create a custom response writer to capture the response body
		writer := &responseWriterWithCapture{
			ResponseWriter: c.Writer,
			body:           bytes.NewBuffer(nil),
		}
		c.Writer = writer

		// Get the trace ID from the request context
		traceID := c.Request.Header.Get("X-Trace-ID")

		// Log the request information
		common.AuditLogger.WithFields(log.Fields{
			"TraceID":     traceID,
			"Method":      c.Request.Method,
			"IP":          c.ClientIP(),
			"URL":         c.Request.URL.Path,
			"RequestBody": common.MaskPassword(string(body)),
		}).Info("Request received")

		common.Logger.WithFields(log.Fields{
			"TraceID":     traceID,
			"Method":      c.Request.Method,
			"IP":          c.ClientIP(),
			"URL":         c.Request.URL.Path,
			"RequestBody": common.MaskPassword(string(body)),
		}).Info("Request received")

		// Process the request
		c.Next()

		// Capture the response body
		responseBody := writer.body.Bytes()

		// Log the response information
		common.AuditLogger.WithFields(log.Fields{
			"TraceID":      traceID,
			"URL":          c.Request.URL.Path,
			"Status":       c.Writer.Status(),
			"ResponseBody": common.MaskPassword(string(responseBody)),
		}).Info("Response")

		common.Logger.WithFields(log.Fields{
			"TraceID":      traceID,
			"URL":          c.Request.URL.Path,
			"Status":       c.Writer.Status(),
			"ResponseBody": common.MaskPassword(string(responseBody)),
		}).Info("Response")
	}
}

// Custom response writer to capture the response body
type responseWriterWithCapture struct {
	gin.ResponseWriter
	body *bytes.Buffer
}

func (w responseWriterWithCapture) Write(b []byte) (int, error) {
	w.body.Write(b)
	return w.ResponseWriter.Write(b)
}

// Middleware function to generate and attach a trace ID to the request context
func TraceMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Generate a unique trace ID
		traceID := common.GenerateTraceID()

		if c.Request.Header.Get("X-Trace-ID") == "" {
			c.Request.Header.Set("X-Trace-ID", traceID)
		}

		// Continue processing the request
		c.Next()
	}
}

func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc {
	return func(c *gin.Context) {
		ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
		defer cancel()

		c.Request = c.Request.WithContext(ctx)
		c.Next()

		if ctx.Err() == context.DeadlineExceeded {
			c.AbortWithStatus(http.StatusRequestTimeout)
		}
	}
}

func I18nMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Next()

		// To any error which is not defined by the applicaiton, it is necessary to have the attribute 'Error' and "ErrorCode" in gin context.
		if err, exist := c.Get("Error"); exist {
			// The error generated by go-playground validator
			if validateErr, ok := err.(validator.ValidationErrors); ok {
				acceptLanguage := "en_US"

				switch c.GetHeader("Accept-Language") {
				case "en_US":
					acceptLanguage = "en_US"
				case "zh_CN":
					acceptLanguage = "zh_Hans_CN"
				}
				if trans, ok := UniTranslator.GetTranslator(acceptLanguage); ok {
					response := gin.H{"error": common.ConvertMapToString(validateErr.Translate(trans))}
					if errorCode, exist := c.Get("ErrorCode"); exist {
						response["error_code"] = errorCode
					}
					c.JSON(http.StatusBadRequest, response)
					return
				}
				// The error defined in the application.
			} else if definedErr, exist := err.(*common.Error); exist {
				localizer := GetLocalizer(c)
				errorCode := definedErr.Error()
				message := localizer.MustLocalize(&i18n.LocalizeConfig{
					MessageID:    errorCode,
					TemplateData: definedErr.Params,
				})
				response := gin.H{"error": message}
				response["error_code"] = errorCode
				c.JSON(http.StatusInternalServerError, response)
				return
				// The error, which does not catch by the application.
			} else {
				response := gin.H{"error": err.(error).Error()}
				if errorCode, exist := c.Get("ErrorCode"); exist {
					response["error_code"] = errorCode
				}
				c.JSON(http.StatusInternalServerError, response)
				return
			}
		}
	}
}
